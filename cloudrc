#!/usr/bin/env bash

#   CLOUDRC - enabled cloud SDKs and aliases
#
#     This script is a component of ConfigCloud
#       https://github.com/robertpeteuil/configcloud
#
#     Robert Peteuil (c) 2018
#

cloudrcname=".cloudrc"
cloudrcnum="2.1.11"
cloudrcdate="2018-03-20"


##### LOAD CONFIG INFO PRESENT
sourceIf "$HOME/.cloud/.cloud_config"

###### VARS
GCP_DOCKER_LOGIN=""

###### FUNCTIONS
sourceIf () {
  if [ -e "$1" ]; then
    . "$1"
  fi
}

##### SOURCE CLOUD SDKs
## AWS
if [ -x /usr/local/bin/aws ]; then
  complete -C aws_completer aws
fi
## AZURE
sourceIf "$HOME/lib/azure-cli/az.completion"
sourceIf "/usr/local/bin/az.completion.sh"
## GCLOUD
sourceIf "$HOME/google-cloud-sdk/path.bash.inc"
sourceIf "$HOME/google-cloud-sdk/completion.bash.inc"
sourceIf "/usr/lib/google-cloud-sdk/completion.bash.inc"
sourceIf "/usr/share/google-cloud-sdk/completion.bash.inc"


##### PROVIDER SPECIFIC ALIASES
## AWS
if [[ -n "$AWS_ACCESS_KEY_ID" ]]; then
  # LIST INSTANCES
  alias aws-list="aws ec2 describe-instances --query 'Reservations[].Instances[].[Tags[?Key==\`Name\`].Value|[0],Placement.AvailabilityZone,InstanceType,PublicIpAddress,State.Name,InstanceLifecycle]' --output table"
  # MOBILE FORMATTED LIST OF INSTANCES
  alias aws-list-m="aws ec2 describe-instances --query 'Reservations[].Instances[].[Tags[?Key==\`Name\`].Value|[0],PublicIpAddress,State.Name]' --output table"
  # LIST RUNNING INSTANCES
  alias aws-list-r="aws ec2 describe-instances --filters 'Name=instance-state-name,Values=running' --query 'Reservations[].Instances[].[Tags[?Key==\`Name\`].Value|[0],Placement.AvailabilityZone,InstanceType,PrivateIpAddress,PublicIpAddress,InstanceLifecycle]' --output table"
fi

## GCLOUD
# GCP CLOUD SHELL
gcp-mount-shell () {
  [[ -z "$1" ]] && echo "Specify \$1 as location to mount shell drive at" && return
  GCP_MNT_DIR="${1/'~'/$HOME}"
  get_cmd="gcloud alpha cloud-shell get-mount-command $GCP_MNT_DIR"
  mnt_cmd=$(bash -c "$get_cmd" | awk '/sshfs/ {print $0}')
  if [[ "$mnt_cmd" ]]; then
    mkdir -p "$GCP_MNT_DIR"
    if $(bash -c "$mnt_cmd"); then
      export GCP_MNT_DIR
      echo "Gcp shell volume mounted at: $GCP_MNT_DIR"
    else
      echo "Mouting with sshfs failed"
      unset GCP_MNT_DIR
    fi
  else
    echo "Retrieving mount string from gcloud util failed"
    unset GCP_MNT_DIR
  fi
}
alias gcp-mount='gcp-mount-shell'
gcp-unmount-shell () {
  [[ -z "$GCP_MNT_DIR" ]] && echo "Gcp shell volume not mounted" && return
  OS=$(uname -s)
  if [ "$OS" == 'Linux' ]; then
    if $(fusermount -u "$GCP_MNT_DIR"); then
      echo "Sucessfully unmounted gcp shell volume"
      unset GCP_MNT_DIR
    fi
  fi
}
alias gcp-unmount='gcp-unmount-shell'
# GCP-GET PROJECT ID
gcp-get-project () {
  [[ -z "$GCP_PROJECT_ID" ]] && GCP_PROJECT_ID=$(gcloud config list 2> /dev/null | awk '/^project/ {print $3}')
}
# GET-GCP-TOKEN
gcp-get-token () {
  GCP_TOKEN=$(curl -s "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token" -H "Metadata-Flavor: Google")
}
# GCP-DOCKER-LOGIN
d-login-gcp () {
  gcp-get-token
  if [[ "$GCP_TOKEN" =~ access_token ]]; then
    echo "gcp-based host - using token login"
    docker login -u oauth2accesstoken -p "$GCP_TOKEN" https://gcr.io
    [[ "$?" == 0 ]] && GCP_DOCKER_LOGIN="success" || GCP_DOCKER_LOGIN="failed"
  elif [[ -n "${GCP_SVR_ACCT_KEY}" ]]; then
    echo "using key based login"
    docker login -u _json_key -p "$(cat $GCP_SVR_ACCT_KEY)" https://gcr.io
    [[ "$?" == 0 ]] && GCP_DOCKER_LOGIN="success" || GCP_DOCKER_LOGIN="failed"
  else
    echo -n "no token or key - "
    GCP_DOCKER_LOGIN="failed"
  fi
  [[ "$GCP_DOCKER_LOGIN" == "failed" ]] && echo "gcp-docker login failed" && return 1
}
alias docker-login-gcp='d-login-gcp'
# PUSH TO GCP IMAGE REPO
d-push-gcp () {
  [[ -z "$1" ]] && echo "specify \$1 as image name to push" && return 1
  gcp-get-project
  [[ -z "$GCP_PROJECT_ID" ]] && echo "gcloud project not set, exiting..." && return 1
  [[ "$GCP_DOCKER_LOGIN" == "failed" ]] && echo "cannot push to gcp-docker - login failed" && return 1
  [[ "$GCP_DOCKER_LOGIN" != "success" ]] && d-login-gcp
  if [[ "$GCP_DOCKER_LOGIN" == "success" ]]; then
    # remove one repo prefix if exists, change to ## to remove all
    image_name=${1#*/}
    docker tag $1 "gcr.io/${GCP_PROJECT_ID}/$image_name"
    docker push "gcr.io/${GCP_PROJECT_ID}/$image_name"
    docker rmi "gcr.io/${GCP_PROJECT_ID}/$image_name"
  fi
}
alias docker-push-gcp='d-push-gcp'
if [ -e "$HOME/.config/gcloud/credentials.db" ]; then
  alias docker-gcp='gcloud docker'
  alias gcp-docker='gcloud docker'
  # LIST INSTANCES
  alias gcp-list="gcloud compute instances list --format='table(name:sort=1, zone, machineType.machine_type().basename(), networkInterfaces[].networkIP.notnull().list():label=INTERNAL_IP, networkInterfaces[].accessConfigs[0].natIP.notnull().list():label=EXTERNAL_IP, status)'"
  # MOBILE FORMATTED LIST OF INSTANCES
  alias gcp-lists="gcloud compute instances list --format='table(name:sort=1, zone, networkInterfaces[].accessConfigs[0].natIP.notnull().list():label=EXTERNAL_IP, status)'"
  # LIST RUNNING INSTANCES
  alias gcp-listrun="gcloud compute instances list --filter STATUS=RUNNING --format='table(name:sort=1, zone, machineType.machine_type().basename(), networkInterfaces[].networkIP.notnull().list():label=INTERNAL_IP, networkInterfaces[].accessConfigs[0].natIP.notnull().list():label=EXTERNAL_IP)'"
  gcp-start() {
    if [[ -n "$1" ]] && [[ -n "$2" ]]; then
      gcloud compute instances start "$1" --zone="$2"
    else
      echo "Two Params Required:"
      echo -e "\t \$1 = NAME, \$2 = ZONE"
    fi
  }
  gcp-stop() {
    if [[ -n "$1" ]] && [[ -n "$2" ]]; then
      gcloud compute instances stop "$1" --zone="$2"
    else
      echo "Two Params Required:"
      echo -e "\t \$1 = NAME, \$2 = ZONE"
    fi
  }
  gcp-ssh() {
    if [[ -n "$1" ]] && [[ -n "$2" ]]; then
      gcloud compute ssh "$1" --zone="$2" --ssh-key-file="~/.ssh/id_rsa" -- -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
    else
      echo "Two Params Required:"
      echo -e "\t \$1 = NAME, \$2 = ZONE"
    fi
  }
fi

## AZURE
if [[ -n "$AZURE_TENANT_ID" ]]; then
  # GET TOKEN USING AZURE CREDS IN ENV VARS
  azure-get-token() {
    AZURE_TOKEN=$(curl -s --header "accept: application/json" --request POST "https://login.windows.net/$AZURE_TENANT_ID/oauth2/token" --data-urlencode "resource=https://management.core.windows.net/" --data-urlencode "client_id=$AZURE_CLIENT_ID" --data-urlencode "grant_type=client_credentials" --data-urlencode "client_secret=$AZURE_CLIENT_SECRET" | jq -r '.access_token')
  }
  # LIST INSTANCES
  azure-list() {
    az vm list -d --query "[].{ name: name, ResourceGroup: resourceGroup, MachineType: hardwareProfile.vmSize, FQDNS: fqdns, State: powerState}" -o=table
  }
  alias az-list='azure-list'
  # MOBILE FORMATTED LIST INSTANCES - NAME, GROUP, STATE
  azure-list-m() {
    az vm list -d --query "[].{ name: name, ResourceGroup: resourceGroup, State: powerState}" -o=table
  }
  alias az-list-m='azure-list-m'
  # MOBILE FORMATTED LIST INSTANCES - NAME & FQDN
  azure-list-m2() {
    az vm list -d --query "[].{ name: name, FQDNS: fqdns}" -o=table
  }
  alias az-list-m2='azure-list-m2'
  # LIST INSTANCES WITH LOCATION
  azure-list-loc() {
    az vm list -d --query "[].{ name: name, ResourceGroup: resourceGroup, Location: location, FQDNS: fqdns, State: powerState}" -o=table
  }
  alias az-list-loc='azure-list-loc'
  # LIST RUNNING INSTANCES
  azure-list-r() {
    az vm list -d --query "[?contains(powerState,'running')].{ name: name, ResourceGroup: resourceGroup, MachineType: hardwareProfile.vmSize, FQDNS: fqdns, PublicIP: publicIps}" -o=table
  }
  alias az-list-r='azure-list-r'
  # START INSTANCE
  az-start() {
    if [[ -z "$2" ]] && [[ -n "$1" ]]; then
      az vm start --ids $(az vm list -g "$1" --query "[].id" -o tsv)
    elif [[ -n "$1" ]] && [[ -n "$2" ]]; then
      az vm start -n "$1" -g "$2"
    else
      echo "One or Two Params Required:"
      echo -e "\t \$1 = GROUP"
      echo -e "\t \$1 = NAME, \$2 = GROUP"
    fi
  }
  # STOP INSTANCE
  az-stop() {
    if [[ -z "$2" ]] && [[ -n "$1" ]]; then
      az vm deallocate --ids $(az vm list -g "$1" --query "[].id" -o tsv) --no-wait
    elif [[ -n "$1" ]] && [[ -n "$2" ]]; then
      az vm deallocate -n "$1" -g "$2"
    else
      echo "One or Two Params Required:"
      echo -e "\t \$1 = GROUP"
      echo -e "\t \$1 = NAME, \$2 = GROUP"
    fi
  }
fi